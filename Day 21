ğ‹ğğğ­ğ‚ğ¨ğğ : ğŸğŸ“ğŸ—ğŸ. ğŒğšğ¤ğ ğ’ğ®ğ¦ ğƒğ¢ğ¯ğ¢ğ¬ğ¢ğ›ğ¥ğ ğ›ğ² ğ
class Solution:
    def minSubarray(self, nums: List[int], p: int) -> int:
        rem = sum(nums) % p
        if rem == 0:
            return 0
        
        length = len(nums)
        h = {0: -1}

        run = [0]
        for i, num in enumerate(nums):
            run.append(run[-1] + num)
            curr = run[-1] % p
            if curr >= rem:
                if curr - rem in h:
                    length = min(length, i-h[curr - rem])
            else:
                if p - rem + curr in h:
                    length = min(length, i-h[p-rem+curr])
            h[curr] = i
        if length == len(nums):
            return -1
        return length


ğ‚ğ¨ğğğ‚ğ¡ğğŸ : ğğ«ğ¢ğ¦ğ ğ†ğğ§ğğ«ğšğ­ğ¨ğ«
# cook your dish here
import sympy
t = int(input())
for _ in range(t):
    N1, N2 = map(int, input().split())
    for Num in range(N1, N2 + 1):
        if sympy.isprime(Num):
            print(Num)
    else:
        print()


ğ†ğğğ¤ğ¬ğ…ğ¨ğ«ğ†ğğğ¤ğ¬ : ğ–ğ¢ğ¥ğğœğšğ«ğ ğ¬ğ­ğ«ğ¢ğ§ğ  ğ¦ğšğ­ğœğ¡ğ¢ğ§ğ 
import re
class Solution:
    def match(self, wild, pattern):
        regex = re.escape(wild).replace(r"\*", ".*").replace(r"\?", ".")
        return re.fullmatch(regex, pattern) is not None


ğˆğ§ğ­ğğ«ğ¯ğ¢ğğ°ğğ¢ğ­ : ğˆğ§ğ¬ğğ«ğ­ğ¢ğ¨ğ§ ğ’ğ¨ğ«ğ­ ğ‹ğ¢ğ¬ğ­
# Definition for singly-linked list.
# class ListNode:
#	def __init__(self, x):
#		self.val = x
#		self.next = None

class Solution:
	# @param A : head node of linked list
	# @return the head node in the linked list
	def insertionSortList(self, A):
        temp = A
        while temp != None:
            traverse = A
            while traverse != temp:
                if traverse.val > temp.val:
                    traverse.val, temp.val = temp.val, traverse.val
                traverse = traverse.next
            temp = temp.next
        return A
