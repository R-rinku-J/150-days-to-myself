ð‚ð¨ððžð‚ð¡ðžðŸ : ð‚ð¡ðžðŸ ðšð§ð ðð«ð¨ð©ð¨ð«ð­ð¢ð¨ð§
# cook your dish here
nums = list(map(int, input().split()))
nums.sort()
if nums[0]/nums[2] == nums[1]/nums[3]:
    print('Possible')
else:
    print('Impossible')


ð†ðžðžð¤ð¬ð…ð¨ð«ð†ðžðžð¤ð¬ : ðŽðœðœð®ð«ðžð§ðœðž ð¨ðŸ ðšð§ ð¢ð§ð­ðžð ðžð« ð¢ð§ ðš ð‹ð¢ð§ð¤ðžð ð‹ð¢ð¬ð­
"""  
class Node:
    def __init__(self, data):
		self.data = data
		self.next = None
  This is method only submission.
  You only need to complete the method.
"""
class Solution:
    def count(self, head, key):
        # Code here
        res = 0
        temp = head
        while temp:
            if temp.data == key:
                res += 1
            temp = temp.next
        return res


ðˆð§ð­ðžð«ð¯ð¢ðžð°ðð¢ð­
ð‘¨ð’Žð’‚ð’›ð’Šð’ð’ˆ ð‘ºð’–ð’ƒð’‚ð’“ð’“ð’‚ð’šð’”
class Solution:
    # @param A : string
    # @return an integer
    def solve(self, A):
        vowels = ['A', 'E', 'I', 'O', 'U']
        text = A.upper()
        count = 0
        for i in range(len(text)):
            if text[i] in vowels:
                count += len(text) - i 
        return count % (10003)

ð‘¹ð’†ð’—ð’†ð’“ð’”ð’† ð‘³ð’Šð’ð’Œð’†ð’… ð‘³ð’Šð’”ð’•
# Definition for singly-linked list.
# class ListNode:
#    def __init__(self, x):
#        self.val = x
#        self.next = None

class Solution:
    # @param A : head node of linked list
    # @return the head node in the linked list
    def reverseList(self, A):
        current = A
        prev = None
        
        while current is not None:
            next = current.next
            current.next = prev
            prev = current
            current = next
            
        head = prev
        return head


ð‹ðžðžð­ð‚ð¨ððž : ðŸðŸ’ðŸ“ðŸ–. ð‡ðžð¢ð ð¡ð­ ð¨ðŸ ðð¢ð§ðšð«ð² ð“ð«ðžðž ð€ðŸð­ðžð« ð’ð®ð›ð­ð«ðžðž ð‘ðžð¦ð¨ð¯ðšð¥ ðð®ðžð«ð¢ðžð¬
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:

        def get_height(root, current):
            if not root: return [0, 0]
            else:
                left = get_height(root.left, current + 1)
                right = get_height(root.right, current + 1)
                root.val = [root.val, current + max(left), current + max(right)]
                return [max(left) + 1, max(right) + 1]
        
        def gen_sol(root, carry, dicts):
            if root.left:
                dicts[root.left.val[0]] = max(carry, root.val[2])
                gen_sol(root.left, max(carry, root.val[2]), dicts)
            if root.right:
                dicts[root.right.val[0]] = max(carry, root.val[1])
                gen_sol(root.right, max(carry, root.val[1]), dicts)
        
        dicts = {}
        get_height(root, 0)
        gen_sol(root, -1, dicts)

        res = []

        for i in queries:
            res.append(dicts[i])
        return res
