ğ‹ğğğ­ğ‚ğ¨ğğ : ğŸğŸ’ğŸğŸ”. ğ’ğ®ğ¦ ğ¨ğŸ ğğ«ğğŸğ¢ğ± ğ’ğœğ¨ğ«ğğ¬ ğ¨ğŸ ğ’ğ­ğ«ğ¢ğ§ğ ğ¬


ğ‚ğ¨ğğğ‚ğ¡ğğŸ : ğ™ğğ«ğ¨ ğ’ğ­ğ«ğ¢ğ§ğ 
for _ in range(int(input())):
    N=int(input())
    S=input()
    one=S.count("1")
    zero=S.count("0")
    if zero>=one:
        val=one
    else:
        val=1+zero
    print(val)


ğ†ğğğ¤ğ¬ğ…ğ¨ğ«ğ†ğğğ¤ğ¬ : ğğšğ¥ğ¢ğ§ğğ«ğ¨ğ¦ğ ğ‹ğ¢ğ§ğ¤ğğ ğ‹ğ¢ğ¬ğ­
class Solution:
    def isPalindrome(self, head):
        #code here
        slow, fast = head, head.next
        while fast and fast.next: slow, fast = slow.next, fast.next.next
        slow = slow.next
        prev = None
        while slow:
            nxt = slow.next
            slow.next = prev
            prev = slow
            slow = nxt
            
        while prev:
            if prev.data != head.data: return False
            prev, head = prev.next, head.next
        return True


ğˆğ§ğ­ğğ«ğ¯ğ¢ğğ°ğğ¢ğ­ : ğŒğ¢ğ§ğ¢ğ¦ğ®ğ¦ ğ€ğ©ğ©ğğ§ğğ¬ ğŸğ¨ğ« ğğšğ¥ğ¢ğ§ğğ«ğ¨ğ¦ğ!(C++)
int Solution::solve(string A) {
    int i=0;
    int j=A.size()-1;
    int k,l;
    while(i<j){
        if(A[i]==A[j]){
            k=i;
            l=j;
            while(k<l && A[k]==A[l]){
                k++;
                l--;
            }
            if(k>=l){
                return i;
            }
            i = k;
        }else{
            i++;
        }
    }
}
