ğ‹ğğğ­ğœğ¨ğğ : ğŸğŸ“ğŸ–ğŸ‘. ğŠğ­ğ¡ ğ‹ğšğ«ğ ğğ¬ğ­ ğ’ğ®ğ¦ ğ¢ğ§ ğš ğğ¢ğ§ğšğ«ğ² ğ“ğ«ğğ
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:
        
        def dfs(node, d):
            if not node:
                return
            
            levels[d] += node.val
            dfs(node.left, d+1)
            dfs(node.right, d+1)
        
        levels = defaultdict(int)
        dfs(root, 0)
        if k > len(levels):
            return -1
        
        return sorted(levels.values())[-k]


ğ‚ğ¨ğğğœğ¡ğğŸ : ğƒğ¢ğ¬ğœğ«ğğ©ğšğ§ğœğ¢ğğ¬ ğ¢ğ§ ğ­ğ¡ğ ğ•ğ¨ğ­ğğ«ğ¬ ğ‹ğ¢ğ¬ğ­
# cook your dish here
a,b,c=map(int,input().split())
x=set([int(input()) for _ in range(a)])
y=set([int(input()) for _ in range(b)])
z=set([int(input()) for _ in range(c)])

ans=(x&y)|(x&z)|(y&z)
ans=list(ans)
print(len(ans))
ans.sort()
[print(x) for x in ans]


ğ†ğğğ¤ğ¬ğ…ğ¨ğ«ğ†ğğğ¤ğ¬ : ğ’ğ®ğ›-ğšğ«ğ«ğšğ²ğ¬ ğ°ğ¢ğ­ğ¡ ğğªğ®ğšğ¥ ğ§ğ®ğ¦ğ›ğğ« ğ¨ğŸ ğ¨ğœğœğ®ğ«ğğ§ğœğğ¬
#User function Template for python3
from collections import defaultdict
class Solution:
    def sameOccurrence(self, arr, x, y):
        # code here
        count = defaultdict(int)
        count[0] = 1
        a = 0
        b = 0
        for i in arr:
            a += 1 if i == x else -1 if i == y else 0
            b += count[a]
            count[a] += 1
        return b


ğˆğ§ğ­ğğ«ğ¯ğ¢ğğ°ğğ¢ğ­ : ğŒğšğ­ğ«ğ¢ğ± ğŒğğğ¢ğšğ§
class Solution:
    # @param A : list of list of integers
    # @return an integer
    def findMedian(self, A):
        res = []
        for  i in A:
            res.extend(i)
        ans = len(res)
        res.sort()
        if ans % 2 !=0:
            return res[ans//2]
        else:
            return (res[n//2]+res[n//2-1])//2
