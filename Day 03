ğ‹ğğğ­ğ‚ğ¨ğğ : ğŸğŸ‘ğŸ•ğŸ. ğ…ğ¢ğ§ğ ğ­ğ¡ğ ğ‹ğ¨ğ§ğ ğğ¬ğ­ ğ’ğ®ğ›ğ¬ğ­ğ«ğ¢ğ§ğ  ğ‚ğ¨ğ§ğ­ğšğ¢ğ§ğ¢ğ§ğ  ğ•ğ¨ğ°ğğ¥ğ¬ ğ¢ğ§ ğ„ğ¯ğğ§ ğ‚ğ¨ğ®ğ§ğ­ğ¬
class Solution:
    def findTheLongestSubstring(self, s: str) -> int:
        mask = 0  
        max_len = 0  
        mask_map = {0: -1}  
        vowels = "aeiou"  

        for i, char in enumerate(s):
            if char in vowels:  
                mask ^= 1 << vowels.index(char)
            if mask in mask_map:
                max_len = max(max_len, i - mask_map[mask])
            else:
                mask_map[mask] = i
        return max_len


ğ‚ğ¨ğğğ‚ğ¡ğğŸ : ğ€ğğ£ğšğœğğ§ğ­ ğ’ğ®ğ¦ ğğšğ«ğ¢ğ­ğ²
# cook your dish here
for i in range(int(input())):
    a=int(input())
    s=input()
    c=s.count('1')
    if(c%2==0):
        print("YES")
    else:
        print("NO")


ğ†ğğğ¤ğ¬ğ…ğ¨ğ«ğ†ğğğ¤ğ¬ : ğğ¢ğ§ğšğ«ğ² ğ“ğ«ğğ ğ­ğ¨ ğƒğ‹ğ‹
#Function to convert a binary tree to doubly linked list.
class Solution:
    def __init__(self):
        self.prev = None  # To keep track of the previous node in inorder traversal
    
    def bToDLL(self, root):
        self.head = None
        
        def inorder(curr):
            if curr is None:
                return
            inorder(curr.left)
        
            if self.prev is None:
                self.head = curr
            else:
                curr.left = self.prev
                self.prev.right = curr
            self.prev = curr
            inorder(curr.right)
        inorder(root)
        return self.head


ğˆğ§ğ­ğğ«ğ¯ğ¢ğğ°ğğ¢ğ­ : ğˆğ¦ğ©ğ¥ğğ¦ğğ§ğ­ ğ’ğ­ğ«ğ’ğ­ğ«
class Solution:
	# @param A : string
	# @param B : string
	# @return an integer
	def strStr(self, A, B):
        if (B not in A):
            return -1
        b = len(B)
        for i in range(len(A) - b + 1):
            if (A[i:i + b] == B):
                return i


ğ‚ğ¨ğğğ…ğ¨ğ«ğœğğ¬ : ğ“ğ¡ğ«ğğ ğğ«ğ¨ğ­ğ¡ğğ«ğ¬
def find_late_brother(a: int, b: int) -> int:
    all_brothers = {1, 2, 3}
    arrived_on_time = {a, b}
    late_brother = all_brothers - arrived_on_time
    return late_brother.pop()
a, b = map(int, input().split())
print(find_late_brother(a, b))


ğ‘³ğ’†ğ’†ğ’•ğ‘ªğ’ğ’…ğ’† : ğ‘¾ğ’†ğ’†ğ’Œğ’ğ’š ğ‘ªğ’ğ’ğ’•ğ’†ğ’”ğ’• 415
ğŸ‘ğŸğŸ–ğŸ—. ğ“ğ¡ğ ğ“ğ°ğ¨ ğ’ğ§ğğšğ¤ğ² ğğ®ğ¦ğ›ğğ«ğ¬ ğ¨ğŸ ğƒğ¢ğ ğ¢ğ­ğ¯ğ¢ğ¥ğ¥ğ
class Solution:
    def getSneakyNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums) - 2
        freq = [0]*n
        res = []
        for num in nums:
            freq[num] += 1
        for i in range(n):
            if freq[i] == 2:
                res.append(i)
        return res

ğŸ‘ğŸğŸ—ğŸ. ğŒğšğ±ğ¢ğ¦ğ®ğ¦ ğŒğ®ğ¥ğ­ğ¢ğ©ğ¥ğ¢ğœğšğ­ğ¢ğ¨ğ§ ğ’ğœğ¨ğ«ğ
class Solution:
    def maxScore(self, a: List[int], b: List[int]) -> int:
        n = len(b)
        dp = [[float('-inf')] * 5 for _ in range(n+1)]
        for i in range(n + 1):
            dp[i][0] = 0
        for i in range(1, n+1):
            for k in range(1, 5):
                dp[i][k] = dp[i-1][k]
                if i >= k:
                    dp[i][k] = max(dp[i][k], dp[i-1][k-1] + a[k-1]*b[i-1])
        return dp[n][4]

ğŸ‘ğŸğŸ—ğŸ. ğŒğ¢ğ§ğ¢ğ¦ğ®ğ¦ ğğ®ğ¦ğ›ğğ« ğ¨ğŸ ğ•ğšğ¥ğ¢ğ ğ’ğ­ğ«ğ¢ğ§ğ ğ¬ ğ­ğ¨ ğ…ğ¨ğ«ğ¦ ğ“ğšğ«ğ ğğ­ ğˆ
ğŸ‘ğŸğŸ—ğŸ. ğŒğ¢ğ§ğ¢ğ¦ğ®ğ¦ ğğ®ğ¦ğ›ğğ« ğ¨ğŸ ğ•ğšğ¥ğ¢ğ ğ’ğ­ğ«ğ¢ğ§ğ ğ¬ ğ­ğ¨ ğ…ğ¨ğ«ğ¦ ğ“ğšğ«ğ ğğ­ ğˆğˆ
